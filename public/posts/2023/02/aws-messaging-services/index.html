<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AWS Messaging Services | Hassen Taidirt</title>
<meta name=keywords content="Architecture,Cloud Computing"><meta name=description content="Comparison of messaging services available in AWS."><meta name=author content="Hassen"><link rel=canonical href=http://localhost:1313/posts/2023/02/aws-messaging-services/><meta name=google-site-verification content="G-CBM4L789H1"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/2023/02/aws-messaging-services/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/2023/02/aws-messaging-services/"><meta property="og:site_name" content="Hassen Taidirt"><meta property="og:title" content="AWS Messaging Services"><meta property="og:description" content="Comparison of messaging services available in AWS."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-16T19:21:00+01:00"><meta property="article:modified_time" content="2023-02-16T19:21:00+01:00"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Cloud Computing"><meta name=twitter:card content="summary"><meta name=twitter:title content="AWS Messaging Services"><meta name=twitter:description content="Comparison of messaging services available in AWS."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"AWS Messaging Services","item":"http://localhost:1313/posts/2023/02/aws-messaging-services/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AWS Messaging Services","name":"AWS Messaging Services","description":"Comparison of messaging services available in AWS.","keywords":["Architecture","Cloud Computing"],"articleBody":"\nHello world!\nIn this post I’m exploring the various AWS services for services massaging. By this, I mean services that allow the different parts of our application (aka: services) to communicate with each other.\nWhy do we need them? Those messaging solutions are very helpful for many reasons:\nDecoupling of applications: Messaging systems are often used to decouple different components of an application, which makes them more resilient and scalable. By using a messaging system like AWS SQS or SNS, each component can operate independently, and if one component fails, it will not bring down the entire application; Real-time processing: Messaging systems can handle large volumes of data in real-time. This can be useful for use cases such as financial trading, social media, e-commerce and IoT applications; Asynchronous processing: Messaging systems are asynchronous, which means they can process messages independently of other services. This can be useful for batch processing, long-running jobs, and other scenarios where processing time is not critical; Scalability: Messaging systems can be scaled horizontally, which means they can handle large amounts of traffic without being affected by bottlenecks or SPOF (single points of failure). This can be useful for applications that need to handle high volumes of traffic or have unpredictable traffic patterns; Event-driven architectures: Messaging systems like AWS EventBridge are used to build event-driven architectures, which enable applications to respond to events in real-time. This can be useful for use cases such as serverless computing, microservices, and event-driven applications; tl;dr: Messaging systems provide a reliable, scalable, and flexible way to handle different types of communication and data processing needs in modern cloud applications.\nNow that you have a good understading of why you might need a messaging system, let’s have a quick look at whet AWS offers as messaging services:\nAWS messaging services In this list, I do not take into account services that target humans, like Amazon Pinpoint, which is a fully managed service that enables sending targeted messages to mobile app users. Also I’ll not talk about AWS SES which is AWS solution to send emails.\nI’ll only focus on services that make applications talk to each other.\nAmazon SNS Amazon Simple Notification Service (SNS) is a fully managed pub/sub messaging service that enables message delivery to multiple recipients or subscribers. It supports a wide range of messaging protocols such as HTTP, email, SMS, and mobile push notifications.\nAmazon SNS is based on the publish/subscribe (pub/sub) messaging paradigm, which allows for decoupling of message producers and consumers (known as subscribers). Subscribers subscribe to a topic, and can all together get any message published by a publisher that sends something in this topic.\nSome of the key building blocks of Amazon SNS are:\nTopics: Topics are logical access points that allow publishers to send messages to one or many subscribers. Publishers can send messages to a topic, and subscribers can receive messages from a topic. Subscribers: Subscribers are endpoints that receive messages published to a topic. Subscribers can be AWS services, HTTP(S) endpoints, email addresses, mobile devices, and more. Publishers: Publishers are applications or services that send messages to a topic. Publishers can be AWS services, mobile apps, web apps, and more. Amazon SNS is a flexible and scalable messaging service that can be used for a variety of use cases. It can be a good choice for applications that require real-time message delivery, fanout scenarios, or decoupling of components. It can also be useful for applications that require multi-region support or high scalability:\nApplication notifications: Which can be useful for alerting users about new content, changes to their account, or other important events. Fanout scenarios to multiple subscribers: This can be useful for distributing messages to multiple endpoints, such as for real-time data processing or chat applications. Scalability: This can be useful for applications that need to handle unpredictable traffic patterns or bursty workloads. Decoupling of components: This makes different components of an application more resilient and scalable. By using Amazon SNS, each component can operate independently, and if one component fails, it will not bring down the entire application. Multi-region support: Finally, Amazon SNS supports message delivery to multiple regions, which can be useful for building applications that require high availability and disaster recovery capabilities. Amazon SQS Amazon Simple Queue Service (SQS) is a fully managed message queuing service that enables decoupling of the components of a cloud application. It provides reliable, highly available, and scalable queuing of messages.\nUnlike Amazon SNS, which is base on the pub/sub paradigm, Amazon SQS is based on the queueing paradigm, which allows for reliable and scalable messaging between producers and consumers through waiting queues.\nBuilding blocks of Amazon SQS are:\nQueues: Queues are named buffers that hold messages sent by producers. Queues can be used to decouple producers and consumers, and to provide reliable and scalable message delivery. Messages: Messages are payloads sent by producers to queues. Messages can contain any type of data, including text, binary data, or metadata. Producers: Producers are applications or services that send messages to a queue. Producers can be AWS services, mobile apps, web apps, and more. Consumers: Consumers are applications or services that receive and process messages from a queue. Consumers can be AWS services, EC2 instances, serverless functions,… etc AWS SQS can be a good choice for applications that require asynchronous processing, load leveling, scaling, or reliability. It can also be useful for applications that require multi-region support or high scalability. Use cases include:\nAsynchronous processing: Amazon SQS can be used to decouple different components of an application, which allows for asynchronous processing of messages. This can be useful for long-running tasks, batch processing, or any scenario where processing time is not critical. Load leveling: This can be used to smooth out spikes in traffic by temporarily storing messages in a queue until they can be processed by a consumer. This can be useful for applications that have unpredictable traffic patterns or bursty workloads. Scaling: The horizontal scalability of Amazon SQS can be useful for applications that need to handle high volumes of traffic or have unpredictable traffic patterns. Reliability: Amazon SQS provides reliable message delivery by storing messages in a queue until they are processed by a consumer. This can be useful for applications that require guaranteed delivery of messages. Multi-region support: Like Amazon SNS, deliverability to multiple regions by Amazon SQS can be useful for building applications that require high availability and disaster recovery capabilities. Amazon MQ Amazon MQ is a managed message broker service that provides support for a variety of messaging protocols, including AMQP, MQTT, STOMP, OpenWire, and WebSocket. Amazon MQ is based on the message broker paradigm, which allows for reliable and secure messaging between producers and consumers. Here are some of the key building blocks of Amazon MQ:\nBrokers: They are message servers that handle the storage, routing, and delivery of messages. Amazon MQ supports both ActiveMQ and RabbitMQ brokers. Queues: They are named buffers that hold messages sent by producers. Queues can be used to decouple producers and consumers, and to provide reliable and scalable message delivery. Topics: They are logical access points that allow publishers to send messages to one or many subscribers. Publishers can send messages to a topic, and subscribers can receive messages from a topic. Producers: They are applications or services that send messages to a broker. Producers can use a variety of messaging protocols to communicate with a broker, including AMQP, MQTT, STOMP, OpenWire, and WebSocket. Consumers: They are applications or services that receive and process messages from a broker. Consumers can use a variety of messaging protocols to communicate with a broker, including AMQP, MQTT, STOMP, OpenWire, and WebSocket. Amazon MQ is a flexible and scalable message broker service that can be used for a variety of use cases. It can be a good choice for applications that require reliable and secure messaging, support for different messaging protocols, and scalability. It can also be useful for applications that require messaging between on-premises and cloud-based environments or for IoT messaging.\nIn more details, use cases are:\nEnterprise messaging: Amazon MQ can be used to provide reliable and secure messaging between different components or services in an enterprise environment: Applications that require high availability, scalability, and security. IoT messaging: Amazon MQ is very good for IoT devices and applications. Cloud messaging: Amazon MQ can be used to provide messaging for cloud-based applications and services. Hybrid messaging: Amazon MQ can be used to provide messaging between on-premises and cloud-based applications and services. This can be useful for scenarios where applications and services need to communicate over a secure and reliable messaging protocol across different environments. Protocol support: Finally, Amazon MQ supports a variety of messaging protocols, which can be useful for applications and services that require specific messaging protocols or need to communicate with legacy systems. Amazon MSK With Amazon Managed Streaming for Apache Kafka (Amazon MSK), we can easily create, configure, and manage Apache Kafka clusters in the AWS cloud. We can also use Amazon MSK to integrate Kafka with other AWS services such as Amazon S3, Amazon Kinesis, and Amazon Elasticsearch Service.\nKey concepts in MSK are:\nClusters: A cluster is a set of broker nodes that run Apache Kafka. MSK automatically manages the configuration and deployment of Kafka brokers within a cluster, making it easy to scale and operate. Topics: A topic is a category or feed name to which messages are published. Kafka organizes messages into topics, and each message published to a topic is delivered to all consumers that subscribe to that topic. Partitions: A partition is a unit of parallelism in Kafka. Each partition is an ordered, immutable sequence of messages that can be consumed by one or more consumers. Producers: A producer is an application that publishes messages to a Kafka topic. Consumers: Finally, a consumer is an application that reads messages from one or more Kafka topics. Amazon MSK can be used for a variety of use cases, such as real-time data processing, data streaming, and event-driven architectures:\nReal-time streaming data processing: Amazon MSK is ideal for processing large amounts of streaming data in real-time, such as log data, sensor data, and other time-series data. Event-driven architecture: Amazon MSK can be used to build event-driven applications that respond to events in real-time, such as customer transactions, user clicks, and other user events. Hybrid cloud integration: Amazon MSK can be used to integrate applications running on-premises with applications running in the cloud, making it easy to build hybrid cloud architectures. Data streaming for machine learning: Amazon MSK can be used to stream data for machine learning models, such as training data or real-time predictions. The next two services are using Kafka under the hood…\nAmazon Kinesis Data Streams Amazon Kinesis Data Streams is a fully managed service that enables real-time processing of streaming data at scale. It provides durable and scalable message streaming and can be used to build custom data processing applications.\nIt is based on the streaming data paradigm, which allows for real-time data ingestion and processing of high-throughput data streams.\nKey building blocks are:\nStreams: Which are ordered sequences of records that producers send to Kinesis Data Streams. Streams can be used to store and process large volumes of data in real time. Shards: Which are partitions within a stream that enable parallel processing of data. Each shard has a fixed capacity for data storage and a maximum rate of data ingestion. Producers: Which are applications or services that send records to a stream. Producers can be AWS services, mobile apps, web apps, and more. Consumers: Which are applications or services that read and process records from a stream. Consumers can be AWS services like EC2 instances, serverless functions, and more. Use cases for Amazon Kinesis Data Streams are:\nReal-time analytics: Kinesis Data Streams can be used to process and analyze large volumes of streaming data in real time. This can be useful for applications that require real-time insights into data, such as fraud detection, anomaly detection, and more. Data processing: Kinesis Data Streams can be used to process and transform data in real time. This can be useful for applications that require real-time data processing, such as ETL (extract, transform, load) processes, data normalization, and more. Log and event processing: Kinesis Data Streams can be used to process logs and events in real time. This can be useful for applications that require real-time analysis of logs and events, such as security monitoring, system monitoring, and more. Streaming data ingestion: Kinesis Data Streams can be used to ingest large volumes of streaming data in real time. This can be useful for applications that require real-time data ingestion, such as IoT data, clickstream data, and more. Scaling: And finally, Kinesis Data Streams can scale horizontally to handle large volumes of data and traffic, which can be useful for applications that need to handle high volumes of traffic or have unpredictable traffic patterns. Overall, Amazon Kinesis Data Streams is a fantastic service that is highly scalable and flexible streaming data service. It can be a good choice for applications that require real-time processing and analysis of streaming data, as well as applications that need to ingest and process large volumes of streaming data. This is perfect for applications that require high scalability and have unpredictable traffic patterns.\nAmazon Kinesis Data Firehose Amazon Kinesis Data Firehose is a fully managed service that enables loading streaming data into data stores or analytics tools such as Amazon S3, Amazon Redshift, Amazon Elasticsearch Service, and Splunk.\nKey building blocks are:\nDelivery streams: Which are the main building block of Amazon Kinesis Data Firehose. They are used to specify the destination where data should be delivered. Delivery streams can be configured to deliver data to Amazon S3, Amazon Redshift, Amazon Elasticsearch Service, and Splunk. Producers: Which are applications or services that send data to the delivery stream. Producers can be AWS services, mobile apps, web apps, and more. Data transformation: Amazon Kinesis Data Firehose can transform the data before delivering it to the destination. The transformation can be done using AWS Lambda or AWS Glue. Use cases include:\nData lake: Kinesis Data Firehose can be used to deliver streaming data to Amazon S3, which can act as a data lake. This can be useful for applications that require storage of large volumes of data for further analysis and processing. Business intelligence: Amazon Kinesis Data Firehose can be used to deliver streaming data to Amazon Redshift, which can be used for business intelligence applications. This can be useful for applications that require real-time insights into data, such as sales trends, customer behavior, …etc. Search and analytics: Which is done by treaming data to Amazon Elasticsearch Service, which can be used for search and analytics applications. This can be useful for applications that require real-time analysis of data, such as log analysis, and security monitoring. Operational intelligence: Finally, Amazon Kinesis Data Firehose can be used to deliver streaming data to Splunk, which can be used for operational intelligence applications. This can be useful for applications that require real-time analysis of data, such as system monitoring, and application performance monitoring. Differences between Amazon Kinesis Data Streams and Kinesis Data Firehose Both of them are AWS services that are used for processing and delivering streaming data. However they have many differences:\nData transformation: Kinesis Data Firehose can transform the data before delivering it to the destination. The transformation can be done using AWS Lambda or AWS Glue. In contrast, Kinesis Data Streams does not natively support data transformation. Data transformation must be done by the application or service that reads the data from the Kinesis Data Stream. Data delivery: Kinesis Data Firehose delivers data to destinations such as Amazon S3, Amazon Redshift, Amazon Elasticsearch Service, and Splunk in near real-time. In contrast, Kinesis Data Streams does not natively deliver data to destinations. Data must be read from the stream by an application or service, and then delivered to the destination. Data persistence: Kinesis Data Streams stores the streaming data for a configurable retention period, allowing applications to replay and process the data multiple times. In contrast, Kinesis Data Firehose does not store the data after it has been delivered to the destination. Data ordering: Kinesis Data Streams guarantees the ordering of data within a partition. In contrast, Kinesis Data Firehose does not guarantee the ordering of data, since it can buffer and deliver data in batches. Cost: Kinesis Data Firehose is a fully managed service that charges based on the volume of data delivered to the destination. In contrast, Kinesis Data Streams charges based on the amount of data ingested, as well as the number of shards used for the stream. To summarize the comparison, Kinesis Data Streams is a more flexible service that provides finer-grained control over the data processing pipeline. It is suitable for applications that require real-time processing and analysis of streaming data, as well as applications that require data persistence and ordering guarantees.\nOn the other hand, Kinesis Data Firehose is a more managed service that simplifies the data delivery process. It is suitable for applications that require near real-time delivery of streaming data to a destination, as well as applications that require data transformation before delivery.\nAmazon EventBridge Amazon EventBridge is a fully managed event bus service that enables building event-driven architectures. It provides a serverless event bus that can route events between AWS services, SaaS applications, and on-premises applications.\nThe key building blocks of Amazon EventBridge are:\nEvent buses: Are the main building block of Amazon EventBridge. They are used to collect and route events from different sources to different targets. Event buses can be created for different applications or teams, and can be used to separate and organize events. Events: Are the data generated by various sources such as AWS services, custom applications, or third-party services. Events can be used to trigger actions or workflows based on specific conditions. Rules: Are used to match events from different sources to specific targets. Rules can be based on event patterns, event content, or custom logic. Targets: Are the endpoints where the events are sent for processing. Targets can be AWS services, custom applications, or third-party services. Some use cases for Amazon EventBridge include:\nServerless applications: Amazon EventBridge can be used to build serverless applications that react to events from various sources. For example, you can use EventBridge to trigger an AWS Lambda function when a file is uploaded to Amazon S3. Event-driven architecture: Amazon EventBridge can be used to build event-driven architectures that connect different services and applications. This can be useful for applications that require real-time integration of data from different sources. Automation: Amazon EventBridge can be used to automate workflows and processes based on events from different sources. For example, you can use EventBridge to trigger an AWS Step Functions workflow when an event occurs. Security and compliance: Amazon EventBridge can be used to monitor and respond to security events and compliance violations. This can be useful for applications that require real-time monitoring and response to security threats. Amazon EventBridge is a highly scalable and flexible service that can be used to connect applications and services using data from different sources. It can be a good choice for applications that require real-time integration of data from different sources, as well as applications that require automation of workflows and processes based on specific events.\nSummary Service Key Features Use Cases Amazon SNS Publish/subscribe messaging model, supports multiple protocols, high throughput, topic-based filtering, mobile push notifications Fan-out broadcasts, real-time notifications, serverless architectures Amazon SQS Queue-based messaging model, supports multiple message types, scalable, high availability, dead-letter queues, visibility timeout Decoupling application components, asynchronous processing, message retries, event-driven architecture Amazon MQ Message broker based on Apache ActiveMQ, supports multiple messaging protocols, high availability, message persistence, message filtering Migration of existing applications to the cloud, integration of on-premises applications with AWS Amazon MSK Managed Apache Kafka service, supports multiple protocols, high throughput, data persistence, data replication, configurable retention Real-time data streaming, data processing, event-driven architecture Amazon Kinesis Data Streams Streaming data service, real-time data processing, scalable, high throughput, data partitioning, data retention Real-time analytics, machine learning, IoT data ingestion, log processing Amazon Kinesis Data Firehose Delivery service for streaming data, data transformation, delivery to multiple destinations, near real-time delivery, fully managed Near real-time data delivery to Amazon S3, Amazon Redshift, and other destinations, data transformation before delivery Amazon EventBridge Serverless event bus, event-driven architecture, multiple event sources and targets, rules engine, customizable Automation, real-time monitoring, serverless applications, security and compliance monitoring Take away AWS offers a variety of messaging services, each with its own unique features and use cases. Choosing the right messaging service depends on our specific needs and requirements:\nIf we need a publish/subscribe messaging model and want to broadcast messages to multiple subscribers, Amazon SNS is a good option.\nIf we need a queue-based messaging model for decoupling application components or asynchronous processing, Amazon SQS is a good choice.\nFor migration of existing applications to the cloud or integration with on-premises applications, Amazon MQ is a good option.\nIf we need a managed Apache Kafka service for real-time data streaming and processing, Amazon MSK is the path to go.\nIf we need a streaming data service for real-time analytics, machine learning, IoT data ingestion, or log processing, Amazon Kinesis Data Streams and Kinesis Data Firehose are both good options, with Kinesis Data Streams providing more control over data processing and partitioning.\nFinally, if we’re building event-driven architectures and need a customizable, serverless event bus, Amazon EventBridge is a good choice.\nOverall, each messaging service has its own strengths and weaknesses.\nCheers,\nHassen\n","wordCount":"3609","inLanguage":"en","datePublished":"2023-02-16T19:21:00+01:00","dateModified":"2023-02-16T19:21:00+01:00","author":{"@type":"Person","name":"Hassen"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/2023/02/aws-messaging-services/"},"publisher":{"@type":"Organization","name":"Hassen Taidirt","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Hassen (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Hassen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">AWS Messaging Services</h1><div class=post-meta><span title='2023-02-16 19:21:00 +0100 +0100'>February 16, 2023</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3609 words&nbsp;·&nbsp;Hassen&nbsp;|&nbsp;<a href=https://github.com/HassenIO/hassen.io/posts/2023/02/aws-messaging-services.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><img alt="A ship in the sea" loading=lazy src=/2023/02/unsplash-envelopes.jpg title="Envelopes we all want to receive"></p><p>Hello world!</p><p>In this post I&rsquo;m exploring the various AWS services for services massaging. By this, I mean services that allow the different parts of our application (aka: services) to communicate with each other.</p><h2 id=why-do-we-need-them>Why do we need them?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-them>#</a></h2><p>Those messaging solutions are very helpful for many reasons:</p><ul><li><strong>Decoupling of applications</strong>: Messaging systems are often used to decouple different components of an application, which makes them more resilient and scalable. By using a messaging system like AWS SQS or SNS, each component can operate independently, and if one component fails, it will not bring down the entire application;</li><li><strong>Real-time processing</strong>: Messaging systems can handle large volumes of data in real-time. This can be useful for use cases such as financial trading, social media, e-commerce and IoT applications;</li><li><strong>Asynchronous processing</strong>: Messaging systems are asynchronous, which means they can process messages independently of other services. This can be useful for batch processing, long-running jobs, and other scenarios where processing time is not critical;</li><li><strong>Scalability</strong>: Messaging systems can be scaled horizontally, which means they can handle large amounts of traffic without being affected by bottlenecks or SPOF (single points of failure). This can be useful for applications that need to handle high volumes of traffic or have unpredictable traffic patterns;</li><li><strong>Event-driven architectures</strong>: Messaging systems like AWS EventBridge are used to build event-driven architectures, which enable applications to respond to events in real-time. This can be useful for use cases such as serverless computing, microservices, and event-driven applications;</li></ul><blockquote><p>tl;dr: Messaging systems provide a reliable, scalable, and flexible way to handle different types of communication and data processing needs in modern cloud applications.</p></blockquote><p>Now that you have a good understading of why you might need a messaging system, let&rsquo;s have a quick look at whet AWS offers as messaging services:</p><h2 id=aws-messaging-services>AWS messaging services<a hidden class=anchor aria-hidden=true href=#aws-messaging-services>#</a></h2><p>In this list, I do not take into account services that target humans, like <strong>Amazon Pinpoint</strong>, which is a fully managed service that enables sending targeted messages to mobile app users. Also I&rsquo;ll not talk about <strong>AWS SES</strong> which is AWS solution to send emails.</p><p>I&rsquo;ll only focus on services that make applications talk to each other.</p><h3 id=amazon-sns>Amazon SNS<a hidden class=anchor aria-hidden=true href=#amazon-sns>#</a></h3><p><a href=https://aws.amazon.com/sns/>Amazon Simple Notification Service (SNS)</a> is a fully managed pub/sub messaging service that enables message delivery to multiple recipients or subscribers. It supports a wide range of messaging protocols such as HTTP, email, SMS, and mobile push notifications.</p><p>Amazon SNS is based on the <strong>publish/subscribe (pub/sub) messaging paradigm</strong>, which allows for decoupling of message producers and consumers (known as subscribers). Subscribers subscribe to a topic, and can all together get any message published by a publisher that sends something in this topic.</p><p><img alt="How SNS works" loading=lazy src=/2023/02/Product-Page-Diagram_Amazon-SNS_Event-Driven-SNS-Compute.png></p><p>Some of the key building blocks of Amazon SNS are:</p><ul><li>Topics: Topics are logical access points that allow publishers to send messages to one or many subscribers. Publishers can send messages to a topic, and subscribers can receive messages from a topic.</li><li>Subscribers: Subscribers are endpoints that receive messages published to a topic. Subscribers can be AWS services, HTTP(S) endpoints, email addresses, mobile devices, and more.</li><li>Publishers: Publishers are applications or services that send messages to a topic. Publishers can be AWS services, mobile apps, web apps, and more.</li></ul><p>Amazon SNS is a flexible and scalable messaging service that can be used for a variety of use cases. It can be a good choice for applications that require real-time message delivery, fanout scenarios, or decoupling of components. It can also be useful for applications that require multi-region support or high scalability:</p><ul><li>Application notifications: Which can be useful for alerting users about new content, changes to their account, or other important events.</li><li>Fanout scenarios to multiple subscribers: This can be useful for distributing messages to multiple endpoints, such as for real-time data processing or chat applications.</li><li>Scalability: This can be useful for applications that need to handle unpredictable traffic patterns or bursty workloads.</li><li>Decoupling of components: This makes different components of an application more resilient and scalable. By using Amazon SNS, each component can operate independently, and if one component fails, it will not bring down the entire application.</li><li>Multi-region support: Finally, Amazon SNS supports message delivery to multiple regions, which can be useful for building applications that require high availability and disaster recovery capabilities.</li></ul><h3 id=amazon-sqs>Amazon SQS<a hidden class=anchor aria-hidden=true href=#amazon-sqs>#</a></h3><p><a href=https://aws.amazon.com/sqs/>Amazon Simple Queue Service (SQS)</a> is a fully managed message queuing service that enables decoupling of the components of a cloud application. It provides reliable, highly available, and scalable queuing of messages.</p><p>Unlike Amazon SNS, which is base on the pub/sub paradigm, Amazon SQS is based on the <strong>queueing paradigm</strong>, which allows for reliable and scalable messaging between producers and consumers through waiting queues.</p><p><img alt="How SQS works" loading=lazy src=/2023/02/Product-page-diagram_Amazon-SQS.png></p><p>Building blocks of Amazon SQS are:</p><ul><li>Queues: Queues are <em>named buffers</em> that hold messages sent by producers. Queues can be used to decouple producers and consumers, and to provide reliable and scalable message delivery.</li><li>Messages: Messages are payloads sent by producers to queues. Messages can contain any type of data, including text, binary data, or metadata.</li><li>Producers: Producers are applications or services that send messages to a queue. Producers can be AWS services, mobile apps, web apps, and more.</li><li>Consumers: Consumers are applications or services that receive and process messages from a queue. Consumers can be AWS services, EC2 instances, serverless functions,&mldr; etc</li></ul><p>AWS SQS can be a good choice for applications that require asynchronous processing, load leveling, scaling, or reliability. It can also be useful for applications that require multi-region support or high scalability. Use cases include:</p><ul><li>Asynchronous processing: Amazon SQS can be used to decouple different components of an application, which allows for asynchronous processing of messages. This can be useful for long-running tasks, batch processing, or any scenario where processing time is not critical.</li><li>Load leveling: This can be used to smooth out spikes in traffic by temporarily storing messages in a queue until they can be processed by a consumer. This can be useful for applications that have unpredictable traffic patterns or bursty workloads.</li><li>Scaling: The horizontal scalability of Amazon SQS can be useful for applications that need to handle high volumes of traffic or have unpredictable traffic patterns.</li><li>Reliability: Amazon SQS provides reliable message delivery by storing messages in a queue until they are processed by a consumer. This can be useful for applications that require <em>guaranteed delivery of messages</em>.</li><li>Multi-region support: Like Amazon SNS, deliverability to multiple regions by Amazon SQS can be useful for building applications that require high availability and disaster recovery capabilities.</li></ul><h3 id=amazon-mq>Amazon MQ<a hidden class=anchor aria-hidden=true href=#amazon-mq>#</a></h3><p><a href=https://aws.amazon.com/amazon-mq/>Amazon MQ</a> is a managed message broker service that provides support for a variety of messaging protocols, including AMQP, MQTT, STOMP, OpenWire, and WebSocket. Amazon MQ is based on the <strong>message broker paradigm</strong>, which allows for reliable and secure messaging between producers and consumers. Here are some of the key building blocks of Amazon MQ:</p><p><img alt="How Amazon MQ works" loading=lazy src=/2023/02/Product-Page-Diagram_Amazon-MQ.png></p><ul><li>Brokers: They are message servers that handle the storage, routing, and delivery of messages. Amazon MQ supports both ActiveMQ and RabbitMQ brokers.</li><li>Queues: They are named buffers that hold messages sent by producers. Queues can be used to decouple producers and consumers, and to provide reliable and scalable message delivery.</li><li>Topics: They are logical access points that allow publishers to send messages to one or many subscribers. Publishers can send messages to a topic, and subscribers can receive messages from a topic.</li><li>Producers: They are applications or services that send messages to a broker. Producers can use a variety of messaging protocols to communicate with a broker, including AMQP, MQTT, STOMP, OpenWire, and WebSocket.</li><li>Consumers: They are applications or services that receive and process messages from a broker. Consumers can use a variety of messaging protocols to communicate with a broker, including AMQP, MQTT, STOMP, OpenWire, and WebSocket.</li></ul><p>Amazon MQ is a flexible and scalable message broker service that can be used for a variety of use cases. It can be a good choice for applications that require reliable and secure messaging, support for different messaging protocols, and scalability. It can also be useful for applications that require messaging between on-premises and cloud-based environments or for IoT messaging.</p><p>In more details, use cases are:</p><ul><li>Enterprise messaging: Amazon MQ can be used to provide reliable and secure messaging between different components or services in an enterprise environment: Applications that require high availability, scalability, and security.</li><li>IoT messaging: Amazon MQ is very good for IoT devices and applications.</li><li>Cloud messaging: Amazon MQ can be used to provide messaging for cloud-based applications and services.</li><li>Hybrid messaging: Amazon MQ can be used to provide messaging between on-premises and cloud-based applications and services. This can be useful for scenarios where applications and services need to communicate over a secure and reliable messaging protocol across different environments.</li><li>Protocol support: Finally, Amazon MQ supports a variety of messaging protocols, which can be useful for applications and services that require specific messaging protocols or need to communicate with legacy systems.</li></ul><h3 id=amazon-msk>Amazon MSK<a hidden class=anchor aria-hidden=true href=#amazon-msk>#</a></h3><p>With <a href=https://aws.amazon.com/msk/>Amazon Managed Streaming for Apache Kafka (Amazon MSK)</a>, we can easily create, configure, and manage Apache Kafka clusters in the AWS cloud. We can also use Amazon MSK to integrate Kafka with other AWS services such as Amazon S3, Amazon Kinesis, and Amazon Elasticsearch Service.</p><p><img alt="How Amazon MSK works" loading=lazy src=/2023/02/Product-page-diagram_MSK-How-It-Works.png></p><p>Key concepts in MSK are:</p><ul><li>Clusters: A cluster is a set of broker nodes that run Apache Kafka. MSK automatically manages the configuration and deployment of Kafka brokers within a cluster, making it easy to scale and operate.</li><li>Topics: A topic is a category or feed name to which messages are published. Kafka organizes messages into topics, and each message published to a topic is delivered to all consumers that subscribe to that topic.</li><li>Partitions: A partition is a unit of parallelism in Kafka. <em>Each partition is an ordered, immutable sequence of messages that can be consumed by one or more consumers</em>.</li><li>Producers: A producer is an application that publishes messages to a Kafka topic.</li><li>Consumers: Finally, a consumer is an application that reads messages from one or more Kafka topics.</li></ul><p>Amazon MSK can be used for a variety of use cases, such as real-time data processing, data streaming, and event-driven architectures:</p><ul><li>Real-time streaming data processing: Amazon MSK is ideal for processing large amounts of streaming data in real-time, such as log data, sensor data, and other time-series data.</li><li>Event-driven architecture: Amazon MSK can be used to build event-driven applications that respond to events in real-time, such as customer transactions, user clicks, and other user events.</li><li>Hybrid cloud integration: Amazon MSK can be used to integrate applications running on-premises with applications running in the cloud, making it easy to build hybrid cloud architectures.</li><li>Data streaming for machine learning: Amazon MSK can be used to stream data for machine learning models, such as training data or real-time predictions.</li></ul><p>The next two services are using Kafka under the hood&mldr;</p><h3 id=amazon-kinesis-data-streams>Amazon Kinesis Data Streams<a hidden class=anchor aria-hidden=true href=#amazon-kinesis-data-streams>#</a></h3><p><a href=https://aws.amazon.com/kinesis/data-streams/>Amazon Kinesis Data Streams</a> is a fully managed service that enables real-time processing of streaming data at scale. It provides durable and scalable message streaming and can be used to build custom data processing applications.</p><p>It is based on the <strong>streaming data paradigm</strong>, which allows for real-time data ingestion and processing of high-throughput data streams.</p><p><img alt="How Amazon Kinesis Data Streams works" loading=lazy src=/2023/02/Product-Page-Diagram_Amazon-Kinesis-Data-Streams.png></p><p>Key building blocks are:</p><ul><li>Streams: Which are ordered sequences of records that producers send to Kinesis Data Streams. Streams can be used to store and process large volumes of data in real time.</li><li>Shards: Which are partitions within a stream that enable parallel processing of data. Each shard has a fixed capacity for data storage and a maximum rate of data ingestion.</li><li>Producers: Which are applications or services that send records to a stream. Producers can be AWS services, mobile apps, web apps, and more.</li><li>Consumers: Which are applications or services that read and process records from a stream. Consumers can be AWS services like EC2 instances, serverless functions, and more.</li></ul><p>Use cases for Amazon Kinesis Data Streams are:</p><ul><li>Real-time analytics: Kinesis Data Streams can be used to process and analyze large volumes of streaming data in real time. This can be useful for applications that require real-time insights into data, such as fraud detection, anomaly detection, and more.</li><li>Data processing: Kinesis Data Streams can be used to process and transform data in real time. This can be useful for applications that require real-time data processing, such as ETL (extract, transform, load) processes, data normalization, and more.</li><li>Log and event processing: Kinesis Data Streams can be used to process logs and events in real time. This can be useful for applications that require real-time analysis of logs and events, such as security monitoring, system monitoring, and more.</li><li>Streaming data ingestion: Kinesis Data Streams can be used to ingest large volumes of streaming data in real time. This can be useful for applications that require real-time data ingestion, such as IoT data, clickstream data, and more.</li><li>Scaling: And finally, Kinesis Data Streams can scale horizontally to handle large volumes of data and traffic, which can be useful for applications that need to handle high volumes of traffic or have unpredictable traffic patterns.</li></ul><p>Overall, Amazon Kinesis Data Streams is a fantastic service that is highly scalable and flexible streaming data service. It can be a good choice for applications that require real-time processing and analysis of streaming data, as well as applications that need to ingest and process large volumes of streaming data. This is perfect for applications that require high scalability and have unpredictable traffic patterns.</p><h3 id=amazon-kinesis-data-firehose>Amazon Kinesis Data Firehose<a hidden class=anchor aria-hidden=true href=#amazon-kinesis-data-firehose>#</a></h3><p><a href=https://aws.amazon.com/kinesis/data-firehose/>Amazon Kinesis Data Firehose</a> is a fully managed service that enables loading streaming data into data stores or analytics tools such as Amazon S3, Amazon Redshift, Amazon Elasticsearch Service, and Splunk.</p><p><img alt="How Amazon Kinesis Data Firehose works" loading=lazy src=/2023/02/Product-page-diagram_Amazon-KDF_HIW-V2-Updated-Diagram.png></p><p>Key building blocks are:</p><ul><li>Delivery streams: Which are the main building block of Amazon Kinesis Data Firehose. They are used to specify the destination where data should be delivered. Delivery streams can be configured to deliver data to Amazon S3, Amazon Redshift, Amazon Elasticsearch Service, and Splunk.</li><li>Producers: Which are applications or services that send data to the delivery stream. Producers can be AWS services, mobile apps, web apps, and more.</li><li>Data transformation: Amazon Kinesis Data Firehose can transform the data before delivering it to the destination. <em>The transformation can be done using AWS Lambda or AWS Glue</em>.</li></ul><p>Use cases include:</p><ul><li>Data lake: Kinesis Data Firehose can be used to deliver streaming data to Amazon S3, which can act as a data lake. This can be useful for applications that require storage of large volumes of data for further analysis and processing.</li><li>Business intelligence: Amazon Kinesis Data Firehose can be used to deliver streaming data to Amazon Redshift, which can be used for business intelligence applications. This can be useful for applications that require real-time insights into data, such as sales trends, customer behavior, &mldr;etc.</li><li>Search and analytics: Which is done by treaming data to Amazon Elasticsearch Service, which can be used for search and analytics applications. This can be useful for applications that require real-time analysis of data, such as log analysis, and security monitoring.</li><li>Operational intelligence: Finally, Amazon Kinesis Data Firehose can be used to deliver streaming data to Splunk, which can be used for operational intelligence applications. This can be useful for applications that require real-time analysis of data, such as system monitoring, and application performance monitoring.</li></ul><h4 id=differences-between-amazon-kinesis-data-streams-and-kinesis-data-firehose>Differences between Amazon Kinesis Data Streams and Kinesis Data Firehose<a hidden class=anchor aria-hidden=true href=#differences-between-amazon-kinesis-data-streams-and-kinesis-data-firehose>#</a></h4><p>Both of them are AWS services that are used for processing and delivering streaming data. However they have many differences:</p><ul><li>Data transformation: Kinesis Data Firehose can transform the data before delivering it to the destination. The transformation can be done using AWS Lambda or AWS Glue. In contrast, Kinesis Data Streams does not natively support data transformation. Data transformation must be done by the application or service that reads the data from the Kinesis Data Stream.</li><li>Data delivery: Kinesis Data Firehose delivers data to destinations such as Amazon S3, Amazon Redshift, Amazon Elasticsearch Service, and Splunk in near real-time. In contrast, Kinesis Data Streams does not natively deliver data to destinations. Data must be read from the stream by an application or service, and then delivered to the destination.</li><li>Data persistence: Kinesis Data Streams stores the streaming data for a configurable retention period, allowing applications to replay and process the data multiple times. In contrast, Kinesis Data Firehose does not store the data after it has been delivered to the destination.</li><li>Data ordering: Kinesis Data Streams guarantees the ordering of data within a partition. In contrast, Kinesis Data Firehose does not guarantee the ordering of data, since it can buffer and deliver data in batches.</li><li>Cost: Kinesis Data Firehose is a fully managed service that charges based on the volume of data delivered to the destination. In contrast, Kinesis Data Streams charges based on the amount of data ingested, as well as the number of shards used for the stream.</li></ul><p>To summarize the comparison, Kinesis Data Streams is a more flexible service that provides finer-grained control over the data processing pipeline. It is suitable for applications that require real-time processing and analysis of streaming data, as well as applications that require data persistence and ordering guarantees.</p><p>On the other hand, Kinesis Data Firehose is a more managed service that simplifies the data delivery process. It is suitable for applications that require near real-time delivery of streaming data to a destination, as well as applications that require data transformation before delivery.</p><h3 id=amazon-eventbridge>Amazon EventBridge<a hidden class=anchor aria-hidden=true href=#amazon-eventbridge>#</a></h3><p><a href=https://aws.amazon.com/eventbridge/>Amazon EventBridge</a> is a fully managed event bus service that enables building event-driven architectures. It provides a serverless event bus that can route events between AWS services, SaaS applications, and on-premises applications.</p><p><img alt="How Amazon EventBridge works" loading=lazy src=/2023/02/Product-Page-Diagram_Amazon-EventBridge.png></p><p>The key building blocks of Amazon EventBridge are:</p><ul><li>Event buses: Are the main building block of Amazon EventBridge. They are used to collect and route events from different sources to different targets. Event buses can be created for different applications or teams, and can be used to separate and organize events.</li><li>Events: Are the data generated by various sources such as AWS services, custom applications, or third-party services. Events can be used to trigger actions or workflows based on specific conditions.</li><li>Rules: Are used to match events from different sources to specific targets. Rules can be based on <em>event patterns, event content, or custom logic</em>.</li><li>Targets: Are the endpoints where the events are sent for processing. Targets can be AWS services, custom applications, or third-party services.</li></ul><p>Some use cases for Amazon EventBridge include:</p><ul><li>Serverless applications: Amazon EventBridge can be used to build serverless applications that react to events from various sources. For example, you can use EventBridge to trigger an AWS Lambda function when a file is uploaded to Amazon S3.</li><li>Event-driven architecture: Amazon EventBridge can be used to build event-driven architectures that connect different services and applications. This can be useful for applications that require real-time integration of data from different sources.</li><li>Automation: Amazon EventBridge can be used to automate workflows and processes based on events from different sources. For example, you can use EventBridge to trigger an AWS Step Functions workflow when an event occurs.</li><li>Security and compliance: Amazon EventBridge can be used to monitor and respond to security events and compliance violations. This can be useful for applications that require real-time monitoring and response to security threats.</li></ul><p>Amazon EventBridge is a highly scalable and flexible service that can be used to connect applications and services using data from different sources. It can be a good choice for applications that require real-time integration of data from different sources, as well as applications that require automation of workflows and processes based on specific events.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><table><thead><tr><th>Service</th><th>Key Features</th><th>Use Cases</th></tr></thead><tbody><tr><td>Amazon SNS</td><td>Publish/subscribe messaging model, supports multiple protocols, high throughput, topic-based filtering, mobile push notifications</td><td>Fan-out broadcasts, real-time notifications, serverless architectures</td></tr><tr><td>Amazon SQS</td><td>Queue-based messaging model, supports multiple message types, scalable, high availability, dead-letter queues, visibility timeout</td><td>Decoupling application components, asynchronous processing, message retries, event-driven architecture</td></tr><tr><td>Amazon MQ</td><td>Message broker based on Apache ActiveMQ, supports multiple messaging protocols, high availability, message persistence, message filtering</td><td>Migration of existing applications to the cloud, integration of on-premises applications with AWS</td></tr><tr><td>Amazon MSK</td><td>Managed Apache Kafka service, supports multiple protocols, high throughput, data persistence, data replication, configurable retention</td><td>Real-time data streaming, data processing, event-driven architecture</td></tr><tr><td>Amazon Kinesis Data Streams</td><td>Streaming data service, real-time data processing, scalable, high throughput, data partitioning, data retention</td><td>Real-time analytics, machine learning, IoT data ingestion, log processing</td></tr><tr><td>Amazon Kinesis Data Firehose</td><td>Delivery service for streaming data, data transformation, delivery to multiple destinations, near real-time delivery, fully managed</td><td>Near real-time data delivery to Amazon S3, Amazon Redshift, and other destinations, data transformation before delivery</td></tr><tr><td>Amazon EventBridge</td><td>Serverless event bus, event-driven architecture, multiple event sources and targets, rules engine, customizable</td><td>Automation, real-time monitoring, serverless applications, security and compliance monitoring</td></tr></tbody></table><h2 id=take-away>Take away<a hidden class=anchor aria-hidden=true href=#take-away>#</a></h2><p>AWS offers a variety of messaging services, each with its own unique features and use cases. Choosing the right messaging service depends on our specific needs and requirements:</p><p>If we need a publish/subscribe messaging model and want to broadcast messages to multiple subscribers, Amazon SNS is a good option.</p><p>If we need a queue-based messaging model for decoupling application components or asynchronous processing, Amazon SQS is a good choice.</p><p>For migration of existing applications to the cloud or integration with on-premises applications, Amazon MQ is a good option.</p><p>If we need a managed Apache Kafka service for real-time data streaming and processing, Amazon MSK is the path to go.</p><p>If we need a streaming data service for real-time analytics, machine learning, IoT data ingestion, or log processing, Amazon Kinesis Data Streams and Kinesis Data Firehose are both good options, with Kinesis Data Streams providing more control over data processing and partitioning.</p><p>Finally, if we&rsquo;re building event-driven architectures and need a customizable, serverless event bus, Amazon EventBridge is a good choice.</p><p>Overall, each messaging service has its own strengths and weaknesses.</p><hr><p>Cheers,</p><p>Hassen</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/architecture/>Architecture</a></li><li><a href=http://localhost:1313/tags/cloud-computing/>Cloud Computing</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/2023/10/ruby-on-rails-dead/><span class=title>« Prev</span><br><span>Ruby on Rails is Dead!... Not So Fast, My Friend!</span>
</a><a class=next href=http://localhost:1313/posts/2022/05/tip-debug-docker-build-fails/><span class=title>Next »</span><br><span>Debug a Docker build failure</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share AWS Messaging Services on x" href="https://x.com/intent/tweet/?text=AWS%20Messaging%20Services&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2f02%2faws-messaging-services%2f&amp;hashtags=Architecture%2cCloudComputing"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AWS Messaging Services on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2f02%2faws-messaging-services%2f&amp;title=AWS%20Messaging%20Services&amp;summary=AWS%20Messaging%20Services&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2f02%2faws-messaging-services%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AWS Messaging Services on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2f02%2faws-messaging-services%2f&title=AWS%20Messaging%20Services"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AWS Messaging Services on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2f02%2faws-messaging-services%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AWS Messaging Services on whatsapp" href="https://api.whatsapp.com/send?text=AWS%20Messaging%20Services%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2f02%2faws-messaging-services%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AWS Messaging Services on telegram" href="https://telegram.me/share/url?text=AWS%20Messaging%20Services&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2f02%2faws-messaging-services%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AWS Messaging Services on ycombinator" href="https://news.ycombinator.com/submitlink?t=AWS%20Messaging%20Services&u=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2f02%2faws-messaging-services%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Hassen Taidirt</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>